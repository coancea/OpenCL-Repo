
#define FUTHARK_CUDA
#define FUTHARK_F64_ENABLED

typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef uint8_t uchar;
typedef uint16_t ushort;
typedef uint32_t uint;
typedef uint64_t ulong;
#define __kernel extern "C" __global__ __launch_bounds__(MAX_THREADS_PER_BLOCK)
#define __global
#define __local
#define __private
#define __constant
#define __write_only
#define __read_only

static inline int get_group_id_fn(int block_dim0, int block_dim1, int block_dim2, int d) {
  switch (d) {
    case 0: d = block_dim0; break;
    case 1: d = block_dim1; break;
    case 2: d = block_dim2; break;
  }
  switch (d) {
    case 0: return blockIdx.x;
    case 1: return blockIdx.y;
    case 2: return blockIdx.z;
    default: return 0;
  }
}
#define get_group_id(d) get_group_id_fn(block_dim0, block_dim1, block_dim2, d)

static inline int get_num_groups_fn(int block_dim0, int block_dim1, int block_dim2, int d) {
  switch (d) {
    case 0: d = block_dim0; break;
    case 1: d = block_dim1; break;
    case 2: d = block_dim2; break;
  }
  switch(d) {
    case 0: return gridDim.x;
    case 1: return gridDim.y;
    case 2: return gridDim.z;
    default: return 0;
  }
}
#define get_num_groups(d) get_num_groups_fn(block_dim0, block_dim1, block_dim2, d)

static inline int get_local_id(int d) {
  switch (d) {
    case 0: return threadIdx.x;
    case 1: return threadIdx.y;
    case 2: return threadIdx.z;
    default: return 0;
  }
}

static inline int get_local_size(int d) {
  switch (d) {
    case 0: return blockDim.x;
    case 1: return blockDim.y;
    case 2: return blockDim.z;
    default: return 0;
  }
}

static inline int get_global_id_fn(int block_dim0, int block_dim1, int block_dim2, int d) {
  return get_group_id(d) * get_local_size(d) + get_local_id(d);
}
#define get_global_id(d) get_global_id_fn(block_dim0, block_dim1, block_dim2, d)

static inline int get_global_size(int block_dim0, int block_dim1, int block_dim2, int d) {
  return get_num_groups(d) * get_local_size(d);
}

#define CLK_LOCAL_MEM_FENCE 1
#define CLK_GLOBAL_MEM_FENCE 2
static inline void barrier(int x) {
  __syncthreads();
}
static inline void mem_fence_local() {
  __threadfence_block();
}
static inline void mem_fence_global() {
  __threadfence();
}

#define NAN (0.0/0.0)
#define INFINITY (1.0/0.0)
extern volatile __shared__ unsigned char shared_mem[];
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

static uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

static float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

// End of half.h.
// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

static inline uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

static inline uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

static inline uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

static inline uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

static inline uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

static inline uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

static inline uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

static inline uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

static inline uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

static inline uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

static inline uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

static inline uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

static inline int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

static inline int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

static inline int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

static inline uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

static inline int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

static inline int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

static inline int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

static inline uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

static inline uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

static inline uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

static inline uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

static inline uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

static inline uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

static inline uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

static inline uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

static inline uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

static inline uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

static inline uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

static inline uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

static inline int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

static inline int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

static inline int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

static inline int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

static inline uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

static inline uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

static inline uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

static inline uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

static inline uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

static inline uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

static inline uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

static inline uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

static inline uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

static inline uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

static inline uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

static inline uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

static inline bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

static inline bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

static inline bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

static inline bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

static inline bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

static inline bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

static inline bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

static inline bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

static inline bool slt8(int8_t x, int8_t y) {
  return x < y;
}

static inline bool slt16(int16_t x, int16_t y) {
  return x < y;
}

static inline bool slt32(int32_t x, int32_t y) {
  return x < y;
}

static inline bool slt64(int64_t x, int64_t y) {
  return x < y;
}

static inline bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

static inline bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

static inline bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

static inline bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

static inline uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline bool itob_i8_bool(int8_t x) {
  return x;
}

static inline bool itob_i16_bool(int16_t x) {
  return x;
}

static inline bool itob_i32_bool(int32_t x) {
  return x;
}

static inline bool itob_i64_bool(int64_t x) {
  return x;
}

static inline int8_t btoi_bool_i8(bool x) {
  return x;
}

static inline int16_t btoi_bool_i16(bool x) {
  return x;
}

static inline int32_t btoi_bool_i32(bool x) {
  return x;
}

static inline int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

static int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

static int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

static int32_t abs32(int32_t x) {
  return abs(x);
}

static int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

static int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

static int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

static int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

static int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

static int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

static int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

static int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  return mul_hi(a, b);
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  return mul_hi(a, b);
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mul_hi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul_hi(a, b);
}

#elif defined(__CUDA_ARCH__)

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mulhi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul64hi(a, b);
}

#else // Not OpenCL or CUDA, but plain C.

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  uint64_t aa = a;
  uint64_t bb = b;

  return aa * bb >> 32;
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  __uint128_t aa = a;
  __uint128_t bb = b;

  return aa * bb >> 64;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return mad_hi(a, b, c);
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return mad_hi(a, b, c);
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return mad_hi(a, b, c);
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return mad_hi(a, b, c);
}

#else // Not OpenCL

static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return futrts_mul_hi8(a, b) + c;
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return futrts_mul_hi16(a, b) + c;
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return futrts_mul_hi32(a, b) + c;
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return futrts_mul_hi64(a, b) + c;
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

static int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

static int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

static int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

static int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

static int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

static int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

static inline float fdiv32(float x, float y) {
  return x / y;
}

static inline float fadd32(float x, float y) {
  return x + y;
}

static inline float fsub32(float x, float y) {
  return x - y;
}

static inline float fmul32(float x, float y) {
  return x * y;
}

static inline bool cmplt32(float x, float y) {
  return x < y;
}

static inline bool cmple32(float x, float y) {
  return x <= y;
}

static inline float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

static inline float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

static inline float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

static inline float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

static inline float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

static inline float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

static inline float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

static inline float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

static inline int8_t fptosi_f32_i8(float x) {
  return (int8_t) x;
}

static inline int16_t fptosi_f32_i16(float x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f32_i32(float x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f32_i64(float x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f32_i8(float x) {
  return (uint8_t) x;
}

static inline uint16_t fptoui_f32_i16(float x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f32_i32(float x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f32_i64(float x) {
  return (uint64_t) x;
}

#ifdef __OPENCL_VERSION__
static inline float fabs32(float x) {
  return fabs(x);
}

static inline float fmax32(float x, float y) {
  return fmax(x, y);
}

static inline float fmin32(float x, float y) {
  return fmin(x, y);
}

static inline float fpow32(float x, float y) {
  return pow(x, y);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float fabs32(float x) {
  return fabsf(x);
}

static inline float fmax32(float x, float y) {
  return fmaxf(x, y);
}

static inline float fmin32(float x, float y) {
  return fminf(x, y);
}

static inline float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan32(float x) {
  return isnan(x);
}

static inline bool futrts_isinf32(float x) {
  return isinf(x);
}

#ifdef __OPENCL_VERSION__
static inline float futrts_log32(float x) {
  return log(x);
}

static inline float futrts_log2_32(float x) {
  return log2(x);
}

static inline float futrts_log10_32(float x) {
  return log10(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return cosh(x);
}

static inline float futrts_sinh32(float x) {
  return sinh(x);
}

static inline float futrts_tanh32(float x) {
  return tanh(x);
}

static inline float futrts_acosh32(float x) {
  return acosh(x);
}

static inline float futrts_asinh32(float x) {
  return asinh(x);
}

static inline float futrts_atanh32(float x) {
  return atanh(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgamma(x);
}

static inline float futrts_lgamma32(float x) {
  return lgamma(x);
}

static inline float fmod32(float x, float y) {
  return fmod(x, y);
}

static inline float futrts_round32(float x) {
  return rint(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

static inline float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

static inline float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float futrts_log32(float x) {
  return logf(x);
}

static inline float futrts_log2_32(float x) {
  return log2f(x);
}

static inline float futrts_log10_32(float x) {
  return log10f(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrtf(x);
}

static inline float futrts_exp32(float x) {
  return expf(x);
}

static inline float futrts_cos32(float x) {
  return cosf(x);
}

static inline float futrts_sin32(float x) {
  return sinf(x);
}

static inline float futrts_tan32(float x) {
  return tanf(x);
}

static inline float futrts_acos32(float x) {
  return acosf(x);
}

static inline float futrts_asin32(float x) {
  return asinf(x);
}

static inline float futrts_atan32(float x) {
  return atanf(x);
}

static inline float futrts_cosh32(float x) {
  return coshf(x);
}

static inline float futrts_sinh32(float x) {
  return sinhf(x);
}

static inline float futrts_tanh32(float x) {
  return tanhf(x);
}

static inline float futrts_acosh32(float x) {
  return acoshf(x);
}

static inline float futrts_asinh32(float x) {
  return asinhf(x);
}

static inline float futrts_atanh32(float x) {
  return atanhf(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgammaf(x);
}

static inline float futrts_lgamma32(float x) {
  return lgammaf(x);
}

static inline float fmod32(float x, float y) {
  return fmodf(x, y);
}

static inline float futrts_round32(float x) {
  return rintf(x);
}

static inline float futrts_floor32(float x) {
  return floorf(x);
}

static inline float futrts_ceil32(float x) {
  return ceilf(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

static inline int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}

static inline float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0) - (x < 0);
}

#ifdef FUTHARK_F64_ENABLED

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline int8_t fptosi_f64_i8(double x) {
  return (int8_t) x;
}

static inline int16_t fptosi_f64_i16(double x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f64_i32(double x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f64_i64(double x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f64_i8(double x) {
  return (uint8_t) x;
}

static inline uint16_t fptoui_f64_i16(double x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f64_i32(double x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f64_i64(double x) {
  return (uint64_t) x;
}

static inline double fabs64(double x) {
  return fabs(x);
}

static inline double fmax64(double x, double y) {
  return fmax(x, y);
}

static inline double fmin64(double x, double y) {
  return fmin(x, y);
}

static inline double fpow64(double x, double y) {
  return pow(x, y);
}

static inline double futrts_log64(double x) {
  return log(x);
}

static inline double futrts_log2_64(double x) {
  return log2(x);
}

static inline double futrts_log10_64(double x) {
  return log10(x);
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return cosh(x);
}

static inline double futrts_sinh64(double x) {
  return sinh(x);
}

static inline double futrts_tanh64(double x) {
  return tanh(x);
}

static inline double futrts_acosh64(double x) {
  return acosh(x);
}

static inline double futrts_asinh64(double x) {
  return asinh(x);
}

static inline double futrts_atanh64(double x) {
  return atanh(x);
}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

static inline double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

static inline double futrts_gamma64(double x) {
  return tgamma(x);
}

static inline double futrts_lgamma64(double x) {
  return lgamma(x);
}

static inline double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

static inline double futrts_round64(double x) {
  return rint(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline bool futrts_isinf64(double x) {
  return isinf(x);
}

static inline int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

static inline double fmod64(double x, double y) {
  return fmod(x, y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

static inline double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600)
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

static inline f16 fadd16(f16 x, f16 y) {
  return x + y;
}

static inline f16 fsub16(f16 x, f16 y) {
  return x - y;
}

static inline f16 fmul16(f16 x, f16 y) {
  return x * y;
}

static inline bool cmplt16(f16 x, f16 y) {
  return x < y;
}

static inline bool cmple16(f16 x, f16 y) {
  return x <= y;
}

static inline f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

static inline f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

static inline f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

static inline f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

static inline f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

static inline f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

static inline f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

static inline f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

static inline int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

static inline int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

static inline uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

#ifndef EMULATE_F16

#ifdef __OPENCL_VERSION__
static inline f16 fabs16(f16 x) {
  return fabs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

static inline f16 fabs16(f16 x) {
  return fabsf(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

static inline bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}

#ifdef __OPENCL_VERSION__
static inline f16 futrts_log16(f16 x) {
  return log(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return log2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return log10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return cos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return sin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tan(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acos(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asin(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atan(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rint(x);
}

static inline f16 futrts_floor16(f16 x) {
  return floor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}

#else // Assume CUDA.

static inline f16 futrts_log16(f16 x) {
  return hlog(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return hexp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return hcos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return hsin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tanf(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acosf(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asinf(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atanf(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rintf(x);
}

static inline f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
static inline int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
static inline f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#else
static inline int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

static inline f16 fabs16(f16 x) {
  return fabs32(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

static inline bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

static inline bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

static inline f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

static inline f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

static inline f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

static inline f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

static inline f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

static inline f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

static inline f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

static inline f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

static inline f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

static inline int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

static inline int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

static inline f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

static inline f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0) - (x < 0);
}

#endif

#endif

static inline float fpconv_f16_f16(f16 x) {
  return x;
}

static inline float fpconv_f16_f32(f16 x) {
  return x;
}

static inline f16 fpconv_f32_f16(float x) {
  return x;
}

#ifdef FUTHARK_F64_ENABLED

static inline double fpconv_f16_f64(f16 x) {
  return (double) x;
}

static inline f16 fpconv_f64_f16(double x) {
  return (f16) x;
}

#endif


// End of scalar_f16.h.
// Start of atomics.h

inline int32_t atomic_xchg_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicExch((int32_t*)p, x);
#else
  return atomic_xor(p, x);
#endif
}

inline int32_t atomic_xchg_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicExch((int32_t*)p, x);
#else
  return atomic_xor(p, x);
#endif
}

inline int32_t atomic_cmpxchg_i32_global(volatile __global int32_t *p,
                                         int32_t cmp, int32_t val) {
#ifdef FUTHARK_CUDA
  return atomicCAS((int32_t*)p, cmp, val);
#else
  return atomic_cmpxchg(p, cmp, val);
#endif
}

inline int32_t atomic_cmpxchg_i32_local(volatile __local int32_t *p,
                                        int32_t cmp, int32_t val) {
#ifdef FUTHARK_CUDA
  return atomicCAS((int32_t*)p, cmp, val);
#else
  return atomic_cmpxchg(p, cmp, val);
#endif
}

inline int32_t atomic_add_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((int32_t*)p, x);
#else
  return atomic_add(p, x);
#endif
}

inline int32_t atomic_add_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((int32_t*)p, x);
#else
  return atomic_add(p, x);
#endif
}

inline float atomic_fadd_f32_global(volatile __global float *p, float x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((float*)p, x);
#else
  union { int32_t i; float f; } old;
  union { int32_t i; float f; } assumed;
  old.f = *p;
  do {
    assumed.f = old.f;
    old.f = old.f + x;
    old.i = atomic_cmpxchg_i32_global((volatile __global int32_t*)p, assumed.i, old.i);
  } while (assumed.i != old.i);
  return old.f;
#endif
}

inline float atomic_fadd_f32_local(volatile __local float *p, float x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((float*)p, x);
#else
  union { int32_t i; float f; } old;
  union { int32_t i; float f; } assumed;
  old.f = *p;
  do {
    assumed.f = old.f;
    old.f = old.f + x;
    old.i = atomic_cmpxchg_i32_local((volatile __local int32_t*)p, assumed.i, old.i);
  } while (assumed.i != old.i);
  return old.f;
#endif
}

inline int32_t atomic_smax_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((int32_t*)p, x);
#else
  return atomic_max(p, x);
#endif
}

inline int32_t atomic_smax_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((int32_t*)p, x);
#else
  return atomic_max(p, x);
#endif
}

inline int32_t atomic_smin_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((int32_t*)p, x);
#else
  return atomic_min(p, x);
#endif
}

inline int32_t atomic_smin_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((int32_t*)p, x);
#else
  return atomic_min(p, x);
#endif
}

inline uint32_t atomic_umax_i32_global(volatile __global uint32_t *p, uint32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((uint32_t*)p, x);
#else
  return atomic_max(p, x);
#endif
}

inline uint32_t atomic_umax_i32_local(volatile __local uint32_t *p, uint32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((uint32_t*)p, x);
#else
  return atomic_max(p, x);
#endif
}

inline uint32_t atomic_umin_i32_global(volatile __global uint32_t *p, uint32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((uint32_t*)p, x);
#else
  return atomic_min(p, x);
#endif
}

inline uint32_t atomic_umin_i32_local(volatile __local uint32_t *p, uint32_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((uint32_t*)p, x);
#else
  return atomic_min(p, x);
#endif
}

inline int32_t atomic_and_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicAnd((int32_t*)p, x);
#else
  return atomic_and(p, x);
#endif
}

inline int32_t atomic_and_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicAnd((int32_t*)p, x);
#else
  return atomic_and(p, x);
#endif
}

inline int32_t atomic_or_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicOr((int32_t*)p, x);
#else
  return atomic_or(p, x);
#endif
}

inline int32_t atomic_or_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicOr((int32_t*)p, x);
#else
  return atomic_or(p, x);
#endif
}

inline int32_t atomic_xor_i32_global(volatile __global int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicXor((int32_t*)p, x);
#else
  return atomic_xor(p, x);
#endif
}

inline int32_t atomic_xor_i32_local(volatile __local int32_t *p, int32_t x) {
#ifdef FUTHARK_CUDA
  return atomicXor((int32_t*)p, x);
#else
  return atomic_xor(p, x);
#endif
}

// Start of 64 bit atomics

inline int64_t atomic_xchg_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicExch((uint64_t*)p, x);
#else
  return atom_xor(p, x);
#endif
}

inline int64_t atomic_xchg_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicExch((uint64_t*)p, x);
#else
  return atom_xor(p, x);
#endif
}

inline int64_t atomic_cmpxchg_i64_global(volatile __global int64_t *p,
                                         int64_t cmp, int64_t val) {
#ifdef FUTHARK_CUDA
  return atomicCAS((uint64_t*)p, cmp, val);
#else
  return atom_cmpxchg(p, cmp, val);
#endif
}

inline int64_t atomic_cmpxchg_i64_local(volatile __local int64_t *p,
                                        int64_t cmp, int64_t val) {
#ifdef FUTHARK_CUDA
  return atomicCAS((uint64_t*)p, cmp, val);
#else
  return atom_cmpxchg(p, cmp, val);
#endif
}

inline int64_t atomic_add_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((uint64_t*)p, x);
#else
  return atom_add(p, x);
#endif
}

inline int64_t atomic_add_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicAdd((uint64_t*)p, x);
#else
  return atom_add(p, x);
#endif
}

#ifdef FUTHARK_F64_ENABLED

inline double atomic_fadd_f64_global(volatile __global double *p, double x) {
#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600
  return atomicAdd((double*)p, x);
#else
  union { int64_t i; double f; } old;
  union { int64_t i; double f; } assumed;
  old.f = *p;
  do {
    assumed.f = old.f;
    old.f = old.f + x;
    old.i = atomic_cmpxchg_i64_global((volatile __global int64_t*)p, assumed.i, old.i);
  } while (assumed.i != old.i);
  return old.f;
#endif
}

inline double atomic_fadd_f64_local(volatile __local double *p, double x) {
#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600
  return atomicAdd((double*)p, x);
#else
  union { int64_t i; double f; } old;
  union { int64_t i; double f; } assumed;
  old.f = *p;
  do {
    assumed.f = old.f;
    old.f = old.f + x;
    old.i = atomic_cmpxchg_i64_local((volatile __local int64_t*)p, assumed.i, old.i);
  } while (assumed.i != old.i);
  return old.f;
#endif
}

#endif

inline int64_t atomic_smax_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((int64_t*)p, x);
#else
  return atom_max(p, x);
#endif
}

inline int64_t atomic_smax_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((int64_t*)p, x);
#else
  return atom_max(p, x);
#endif
}

inline int64_t atomic_smin_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((int64_t*)p, x);
#else
  return atom_min(p, x);
#endif
}

inline int64_t atomic_smin_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((int64_t*)p, x);
#else
  return atom_min(p, x);
#endif
}

inline uint64_t atomic_umax_i64_global(volatile __global uint64_t *p, uint64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((uint64_t*)p, x);
#else
  return atom_max(p, x);
#endif
}

inline uint64_t atomic_umax_i64_local(volatile __local uint64_t *p, uint64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMax((uint64_t*)p, x);
#else
  return atom_max(p, x);
#endif
}

inline uint64_t atomic_umin_i64_global(volatile __global uint64_t *p, uint64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((uint64_t*)p, x);
#else
  return atom_min(p, x);
#endif
}

inline uint64_t atomic_umin_i64_local(volatile __local uint64_t *p, uint64_t x) {
#ifdef FUTHARK_CUDA
  return atomicMin((uint64_t*)p, x);
#else
  return atom_min(p, x);
#endif
}

inline int64_t atomic_and_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicAnd((int64_t*)p, x);
#else
  return atom_and(p, x);
#endif
}

inline int64_t atomic_and_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicAnd((int64_t*)p, x);
#else
  return atom_and(p, x);
#endif
}

inline int64_t atomic_or_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicOr((int64_t*)p, x);
#else
  return atom_or(p, x);
#endif
}

inline int64_t atomic_or_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicOr((int64_t*)p, x);
#else
  return atom_or(p, x);
#endif
}

inline int64_t atomic_xor_i64_global(volatile __global int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicXor((int64_t*)p, x);
#else
  return atom_xor(p, x);
#endif
}

inline int64_t atomic_xor_i64_local(volatile __local int64_t *p, int64_t x) {
#ifdef FUTHARK_CUDA
  return atomicXor((int64_t*)p, x);
#else
  return atom_xor(p, x);
#endif
}

// End of atomics.h



__kernel void gpu_map_transpose_f32(const int block_dim0, const int block_dim1,
                                    const int block_dim2,
                                    uint block_9_backing_offset_0,
                                    int32_t destoffset_1, int32_t srcoffset_3,
                                    int32_t num_arrays_4, int32_t x_elems_5,
                                    int32_t y_elems_6, int32_t mulx_7,
                                    int32_t muly_8, __global
                                    unsigned char *destmem_0, __global
                                    unsigned char *srcmem_2)
{
    volatile unsigned char *block_9_backing_0 =
                           &shared_mem[block_9_backing_offset_0];
    __local unsigned char *block_9;
    
    block_9 = (__local unsigned char *) block_9_backing_0;
    
    int32_t get_global_id_0_37;
    
    get_global_id_0_37 = get_global_id(0);
    
    int32_t get_local_id_0_38;
    
    get_local_id_0_38 = get_local_id(0);
    
    int32_t get_local_id_1_39;
    
    get_local_id_1_39 = get_local_id(1);
    
    int32_t get_group_id_0_40;
    
    get_group_id_0_40 = get_group_id(0);
    
    int32_t get_group_id_1_41;
    
    get_group_id_1_41 = get_group_id(1);
    
    int32_t get_group_id_2_42;
    
    get_group_id_2_42 = get_group_id(2);
    
    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;
    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;
    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;
    int32_t x_index_31 = get_global_id_0_37;
    int32_t y_index_32 = get_group_id_1_41 * 32 + get_local_id_1_39;
    float val_44;
    
    if (slt32(x_index_31, x_elems_5)) {
        for (int32_t j_43 = 0; j_43 < 4; j_43++) {
            int32_t index_in_35 = (y_index_32 + j_43 * 8) * x_elems_5 +
                    x_index_31;
            
            if (slt32(y_index_32 + j_43 * 8, y_elems_6)) {
                val_44 = ((__global
                           float *) srcmem_2)[sext_i32_i64(idata_offset_34 +
                                              index_in_35)];
                ((__local float *) block_9)[sext_i32_i64((get_local_id_1_39 +
                                                          j_43 * 8) * 33 +
                                            get_local_id_0_38)] = val_44;
            }
        }
    }
    barrier(CLK_LOCAL_MEM_FENCE);
    x_index_31 = get_group_id_1_41 * 32 + get_local_id_0_38;
    y_index_32 = get_group_id_0_40 * 32 + get_local_id_1_39;
    if (slt32(x_index_31, y_elems_6)) {
        for (int32_t j_43 = 0; j_43 < 4; j_43++) {
            int32_t index_out_36 = (y_index_32 + j_43 * 8) * y_elems_6 +
                    x_index_31;
            
            if (slt32(y_index_32 + j_43 * 8, x_elems_5)) {
                val_44 = ((__local
                           float *) block_9)[sext_i32_i64(get_local_id_0_38 *
                                             33 + get_local_id_1_39 + j_43 *
                                             8)];
                ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +
                                               index_out_36)] = val_44;
            }
        }
    }
    
  error_0:
    return;
}
__kernel void gpu_map_transpose_f32_low_height(const int block_dim0, const
                                               int block_dim1, const
                                               int block_dim2,
                                               uint block_9_backing_offset_0,
                                               int32_t destoffset_1,
                                               int32_t srcoffset_3,
                                               int32_t num_arrays_4,
                                               int32_t x_elems_5,
                                               int32_t y_elems_6,
                                               int32_t mulx_7, int32_t muly_8,
                                               __global
                                               unsigned char *destmem_0,
                                               __global unsigned char *srcmem_2)
{
    volatile unsigned char *block_9_backing_0 =
                           &shared_mem[block_9_backing_offset_0];
    __local unsigned char *block_9;
    
    block_9 = (__local unsigned char *) block_9_backing_0;
    
    int32_t get_global_id_0_37;
    
    get_global_id_0_37 = get_global_id(0);
    
    int32_t get_local_id_0_38;
    
    get_local_id_0_38 = get_local_id(0);
    
    int32_t get_local_id_1_39;
    
    get_local_id_1_39 = get_local_id(1);
    
    int32_t get_group_id_0_40;
    
    get_group_id_0_40 = get_group_id(0);
    
    int32_t get_group_id_1_41;
    
    get_group_id_1_41 = get_group_id(1);
    
    int32_t get_group_id_2_42;
    
    get_group_id_2_42 = get_group_id(2);
    
    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;
    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;
    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;
    int32_t x_index_31 = get_group_id_0_40 * 16 * mulx_7 + get_local_id_0_38 +
            srem32(get_local_id_1_39, mulx_7) * 16;
    int32_t y_index_32 = get_group_id_1_41 * 16 + squot32(get_local_id_1_39,
                                                          mulx_7);
    float val_44;
    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;
    
    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {
        val_44 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 +
                                               index_in_35)];
        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +
                                    get_local_id_0_38)] = val_44;
    }
    barrier(CLK_LOCAL_MEM_FENCE);
    x_index_31 = get_group_id_1_41 * 16 + squot32(get_local_id_0_38, mulx_7);
    y_index_32 = get_group_id_0_40 * 16 * mulx_7 + get_local_id_1_39 +
        srem32(get_local_id_0_38, mulx_7) * 16;
    
    int32_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;
    
    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {
        val_44 = ((__local float *) block_9)[sext_i32_i64(get_local_id_0_38 *
                                             17 + get_local_id_1_39)];
        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +
                                       index_out_36)] = val_44;
    }
    
  error_0:
    return;
}
__kernel void gpu_map_transpose_f32_low_width(const int block_dim0, const
                                              int block_dim1, const
                                              int block_dim2,
                                              uint block_9_backing_offset_0,
                                              int32_t destoffset_1,
                                              int32_t srcoffset_3,
                                              int32_t num_arrays_4,
                                              int32_t x_elems_5,
                                              int32_t y_elems_6, int32_t mulx_7,
                                              int32_t muly_8, __global
                                              unsigned char *destmem_0, __global
                                              unsigned char *srcmem_2)
{
    volatile unsigned char *block_9_backing_0 =
                           &shared_mem[block_9_backing_offset_0];
    __local unsigned char *block_9;
    
    block_9 = (__local unsigned char *) block_9_backing_0;
    
    int32_t get_global_id_0_37;
    
    get_global_id_0_37 = get_global_id(0);
    
    int32_t get_local_id_0_38;
    
    get_local_id_0_38 = get_local_id(0);
    
    int32_t get_local_id_1_39;
    
    get_local_id_1_39 = get_local_id(1);
    
    int32_t get_group_id_0_40;
    
    get_group_id_0_40 = get_group_id(0);
    
    int32_t get_group_id_1_41;
    
    get_group_id_1_41 = get_group_id(1);
    
    int32_t get_group_id_2_42;
    
    get_group_id_2_42 = get_group_id(2);
    
    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;
    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;
    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;
    int32_t x_index_31 = get_group_id_0_40 * 16 + squot32(get_local_id_0_38,
                                                          muly_8);
    int32_t y_index_32 = get_group_id_1_41 * 16 * muly_8 + get_local_id_1_39 +
            srem32(get_local_id_0_38, muly_8) * 16;
    float val_44;
    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;
    
    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {
        val_44 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 +
                                               index_in_35)];
        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +
                                    get_local_id_0_38)] = val_44;
    }
    barrier(CLK_LOCAL_MEM_FENCE);
    x_index_31 = get_group_id_1_41 * 16 * muly_8 + get_local_id_0_38 +
        srem32(get_local_id_1_39, muly_8) * 16;
    y_index_32 = get_group_id_0_40 * 16 + squot32(get_local_id_1_39, muly_8);
    
    int32_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;
    
    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {
        val_44 = ((__local float *) block_9)[sext_i32_i64(get_local_id_0_38 *
                                             17 + get_local_id_1_39)];
        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +
                                       index_out_36)] = val_44;
    }
    
  error_0:
    return;
}
__kernel void gpu_map_transpose_f32_small(uint block_9_backing_offset_0,
                                          int32_t destoffset_1,
                                          int32_t srcoffset_3,
                                          int32_t num_arrays_4,
                                          int32_t x_elems_5, int32_t y_elems_6,
                                          int32_t mulx_7, int32_t muly_8,
                                          __global unsigned char *destmem_0,
                                          __global unsigned char *srcmem_2)
{
    const int block_dim0 = 0;
    const int block_dim1 = 1;
    const int block_dim2 = 2;
    volatile unsigned char *block_9_backing_0 =
                           &shared_mem[block_9_backing_offset_0];
    __local unsigned char *block_9;
    
    block_9 = (__local unsigned char *) block_9_backing_0;
    
    int32_t get_global_id_0_37;
    
    get_global_id_0_37 = get_global_id(0);
    
    int32_t get_local_id_0_38;
    
    get_local_id_0_38 = get_local_id(0);
    
    int32_t get_local_id_1_39;
    
    get_local_id_1_39 = get_local_id(1);
    
    int32_t get_group_id_0_40;
    
    get_group_id_0_40 = get_group_id(0);
    
    int32_t get_group_id_1_41;
    
    get_group_id_1_41 = get_group_id(1);
    
    int32_t get_group_id_2_42;
    
    get_group_id_2_42 = get_group_id(2);
    
    int32_t our_array_offset_30 = squot32(get_global_id_0_37, y_elems_6 *
                                          x_elems_5) * (y_elems_6 * x_elems_5);
    int32_t x_index_31 = squot32(srem32(get_global_id_0_37, y_elems_6 *
                                        x_elems_5), y_elems_6);
    int32_t y_index_32 = srem32(get_global_id_0_37, y_elems_6);
    float val_44;
    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;
    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;
    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;
    int32_t index_out_36 = x_index_31 * y_elems_6 + y_index_32;
    
    if (slt32(get_global_id_0_37, x_elems_5 * y_elems_6 * num_arrays_4)) {
        val_44 = ((__global float *) srcmem_2)[sext_i32_i64(idata_offset_34 +
                                               index_in_35)];
        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +
                                       index_out_36)] = val_44;
    }
    
  error_0:
    return;
}
__kernel void mainzisegmap_5415(__global int *global_failure, int64_t n_5370,
                                int64_t m_5371, int64_t p_5372,
                                int64_t num_groups_5411,
                                int64_t num_threads_6346, __global
                                unsigned char *yss_mem_6060, __global
                                unsigned char *mem_6063, __global
                                unsigned char *mem_6082, __global
                                unsigned char *color_6331)
{
    #define segmap_group_sizze_5410 (mainzisegmap_group_sizze_5392)
    
    const int block_dim0 = 0;
    const int block_dim1 = 1;
    const int block_dim2 = 2;
    
    if (*global_failure >= 0)
        return;
    
    int32_t global_tid_6353;
    int32_t local_tid_6354;
    int64_t group_sizze_6357;
    int32_t wave_sizze_6356;
    int32_t group_tid_6355;
    
    global_tid_6353 = get_global_id(0);
    local_tid_6354 = get_local_id(0);
    group_sizze_6357 = get_local_size(0);
    wave_sizze_6356 = LOCKSTEP_WIDTH;
    group_tid_6355 = get_group_id(0);
    
    int32_t phys_tid_5415 = global_tid_6353;
    int32_t phys_group_id_6358;
    
    phys_group_id_6358 = get_group_id(0);
    for (int32_t i_6359 = 0; i_6359 < sdiv_up32(sext_i64_i32(sdiv_up64(n_5370,
                                                                       segmap_group_sizze_5410)) -
                                                phys_group_id_6358,
                                                sext_i64_i32(num_groups_5411));
         i_6359++) {
        int32_t virt_group_id_6360 = phys_group_id_6358 + i_6359 *
                sext_i64_i32(num_groups_5411);
        int64_t global_tid_6361 = sext_i32_i64(virt_group_id_6360) *
                segmap_group_sizze_5410 + sext_i32_i64(local_tid_6354);
        int64_t slice_6362 = n_5370;
        int64_t gtid_5414 = global_tid_6361;
        int64_t remnant_6363 = global_tid_6361 - gtid_5414;
        
        if (slt64(gtid_5414, n_5370)) {
            for (int64_t i_6055 = 0; i_6055 < p_5372; i_6055++) {
                float defunc_2_reduce_res_5419;
                float redout_6057 = 0.0F;
                
                for (int64_t i_6058 = 0; i_6058 < m_5371; i_6058++) {
                    float x_5423;
                    
                    x_5423 = ((__global float *) mem_6063)[i_6058 * n_5370 +
                                                           gtid_5414];
                    
                    float x_5424;
                    
                    x_5424 = ((__global float *) yss_mem_6060)[i_6058 * p_5372 +
                                                               i_6055];
                    
                    float defunc_1_f_res_5425 = x_5423 * x_5424;
                    float defunc_1_op_res_5422 = defunc_1_f_res_5425 +
                          redout_6057;
                    float redout_tmp_6365 = defunc_1_op_res_5422;
                    
                    redout_6057 = redout_tmp_6365;
                }
                defunc_2_reduce_res_5419 = redout_6057;
                ((__global float *) color_6331)[phys_tid_5415 + i_6055 *
                                                num_threads_6346] =
                    defunc_2_reduce_res_5419;
            }
            for (int64_t i_6366 = 0; i_6366 < p_5372; i_6366++) {
                float tmp_6367;
                
                tmp_6367 = ((__global float *) color_6331)[phys_tid_5415 +
                                                           i_6366 *
                                                           num_threads_6346];
                ((__global float *) mem_6082)[gtid_5414 + i_6366 * n_5370] =
                    tmp_6367;
            }
        }
        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
    }
    
  error_0:
    return;
    #undef segmap_group_sizze_5410
}
__kernel void mainzisegmap_intragroup_5571(__global int *global_failure,
                                           uint color_6344_backing_offset_0,
                                           uint color_6343_backing_offset_1,
                                           int64_t n_5370, int64_t m_5371,
                                           int64_t p_5372,
                                           int64_t gridDim_x_5565,
                                           int64_t gridDim_y_5566,
                                           int64_t full_tiles_5599,
                                           int64_t kk_5822, __global
                                           unsigned char *xss_mem_6059, __global
                                           unsigned char *yss_mem_6060, __global
                                           unsigned char *mem_6277)
{
    #define Ty_5546 (mainziTy_5543)
    #define Ry_5547 (mainziRy_5545)
    #define Tx_5548 (mainziTx_5542)
    #define Rx_5549 (mainziRx_5544)
    #define Tk_5550 (mainziTk_5541)
    #define tk_div_tx_5551 (sdiv_up64(mainziTk_5541, mainziTx_5542))
    #define TxRx_5553 (mainziTx_5542 * mainziRx_5544)
    #define TyRy_5554 (mainziTy_5543 * mainziRy_5545)
    #define a_loc_szz_5559 (mainziTk_5541 * (mainziTy_5543 * mainziRy_5545) + smax64(mainziTk_5541, mainziTy_5543 * mainziRy_5545))
    #define b_loc_szz_5564 (smax64(mainziTk_5541, mainziTy_5543 * mainziRy_5545) + mainziTk_5541 * (mainziTx_5542 * mainziRx_5544))
    #define binop_y_5731 ((int64_t) 1 + mainziTk_5541)
    #define binop_y_5742 ((int64_t) 1 + mainziTx_5542 * mainziRx_5544)
    
    const int block_dim0 = 0;
    const int block_dim1 = 1;
    const int block_dim2 = 2;
    volatile unsigned char *color_6344_backing_1 =
                           &shared_mem[color_6344_backing_offset_0];
    volatile unsigned char *color_6343_backing_0 =
                           &shared_mem[color_6343_backing_offset_1];
    
    if (*global_failure >= 0)
        return;
    
    int32_t global_tid_6368;
    int32_t local_tid_6369;
    int64_t group_sizze_6372;
    int32_t wave_sizze_6371;
    int32_t group_tid_6370;
    
    global_tid_6368 = get_global_id(0);
    local_tid_6369 = get_local_id(0);
    group_sizze_6372 = get_local_size(0);
    wave_sizze_6371 = LOCKSTEP_WIDTH;
    group_tid_6370 = get_group_id(0);
    
    int32_t gid_flat_5571 = group_tid_6370;
    int64_t slice_6375 = Tx_5548;
    int64_t slice_6376 = Ty_5546 * slice_6375;
    int64_t ltid_pre_6373 = squot64(sext_i32_i64(local_tid_6369), slice_6375);
    int64_t remnant_6377 = sext_i32_i64(local_tid_6369) - ltid_pre_6373 *
            slice_6375;
    int64_t ltid_pre_6374 = remnant_6377;
    int64_t remnant_6378 = remnant_6377 - ltid_pre_6374;
    int64_t slice_6381 = Tx_5548;
    int64_t slice_6382 = Tx_5548 * slice_6381;
    int64_t ltid_pre_6379 = squot64(sext_i32_i64(local_tid_6369), slice_6381);
    int64_t remnant_6383 = sext_i32_i64(local_tid_6369) - ltid_pre_6379 *
            slice_6381;
    int64_t ltid_pre_6380 = remnant_6383;
    int64_t remnant_6384 = remnant_6383 - ltid_pre_6380;
    int64_t slice_6385 = gridDim_x_5565;
    int64_t slice_6386 = gridDim_y_5566 * slice_6385;
    int64_t gid_y_5569 = squot64(sext_i32_i64(group_tid_6370), slice_6385);
    int64_t remnant_6387 = sext_i32_i64(group_tid_6370) - gid_y_5569 *
            slice_6385;
    int64_t gid_x_5570 = remnant_6387;
    int64_t remnant_6388 = remnant_6387 - gid_x_5570;
    float color_6338[Ry_5547 * Rx_5549];
    float color_6339[Ry_5547 * Rx_5549];
    float color_6340[Ry_5547 * Rx_5549];
    float color_6341[Rx_5549];
    float color_6342[Rx_5549];
    __local unsigned char *color_6343;
    
    color_6343 = (__local unsigned char *) color_6343_backing_0;
    
    __local unsigned char *color_6344;
    
    color_6344 = (__local unsigned char *) color_6344_backing_1;
    
    float color_6345[Ry_5547 * Rx_5549];
    int64_t iii_5572 = TyRy_5554 * gid_y_5569;
    int64_t jjj_5573 = TxRx_5553 * gid_x_5570;
    int64_t ltid_y_5586 = sext_i32_i64(sext_i64_i32(ltid_pre_6373));
    int64_t ltid_x_5585 = sext_i32_i64(sext_i64_i32(ltid_pre_6374));
    int32_t ltid_flat_5587 = local_tid_6369;
    float color_6332[Ry_5547 * Rx_5549];
    
    for (int64_t i_5590 = 0; i_5590 < Ry_5547; i_5590++) {
        for (int64_t i_5593 = 0; i_5593 < Rx_5549; i_5593++) {
            color_6332[i_5590 * Rx_5549 + i_5593] = 0.0F;
        }
    }
    for (int64_t i_6391 = 0; i_6391 < Ry_5547; i_6391++) {
        for (int64_t i_6392 = 0; i_6392 < Rx_5549; i_6392++) {
            float tmp_6393;
            
            tmp_6393 = color_6332[i_6391 * Rx_5549 + i_6392];
            color_6345[i_6391 * Rx_5549 + i_6392] = tmp_6393;
        }
    }
    barrier(CLK_LOCAL_MEM_FENCE);
    
    float ext_mem_6192[Ry_5547 * Rx_5549];
    float mem_param_6103[Ry_5547 * Rx_5549];
    
    for (int32_t i_2 = 0; i_2 < Ry_5547 * Rx_5549; i_2++)
        mem_param_6103[i_2] = color_6345[i_2];
    for (int64_t i_5600 = 0; i_5600 < full_tiles_5599; i_5600++) {
        int64_t kk_5604 = Tk_5550 * i_5600;
        
        for (int64_t i_5605 = 0; i_5605 < Rx_5549; i_5605++) {
            int64_t binop_y_5632 = Tx_5548 * i_5605;
            
            for (int64_t i_5607 = 0; i_5607 < tk_div_tx_5551; i_5607++) {
                int64_t binop_y_5630 = Tx_5548 * i_5607;
                int64_t ltid_y_5628 = sext_i32_i64(sext_i64_i32(ltid_pre_6379));
                int64_t ltid_x_5629 = sext_i32_i64(sext_i64_i32(ltid_pre_6380));
                int32_t ltid_flat_5627 = local_tid_6369;
                int64_t k_5631 = ltid_x_5629 + binop_y_5630;
                int64_t i_5633 = ltid_y_5628 + binop_y_5632;
                int64_t gtid_5634 = iii_5572 + i_5633;
                int64_t x_seqdim_idx_5635 = kk_5604 + k_5631;
                bool cond_5636 = slt64(gtid_5634, n_5370);
                float x_elem_5637;
                
                if (cond_5636) {
                    float A_elem_5639;
                    
                    A_elem_5639 = ((__global float *) xss_mem_6059)[gtid_5634 *
                                                                    m_5371 +
                                                                    x_seqdim_idx_5635];
                    x_elem_5637 = A_elem_5639;
                } else {
                    x_elem_5637 = 0.0F;
                }
                
                bool cond_5641 = slt64(k_5631, Tk_5550);
                int64_t x_loc_ind_5642;
                
                if (cond_5641) {
                    int64_t binop_y_5643 = (int64_t) 1 + Tk_5550;
                    int64_t binop_y_5644 = i_5633 * binop_y_5643;
                    int64_t loc_fi_5645 = k_5631 + binop_y_5644;
                    
                    x_loc_ind_5642 = loc_fi_5645;
                } else {
                    x_loc_ind_5642 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, x_loc_ind_5642) && slt64(x_loc_ind_5642,
                                                                a_loc_szz_5559)) {
                    ((__local float *) color_6344)[x_loc_ind_5642] =
                        x_elem_5637;
                }
                barrier(CLK_LOCAL_MEM_FENCE);
            }
        }
        for (int64_t i_5650 = 0; i_5650 < tk_div_tx_5551; i_5650++) {
            int64_t binop_y_5675 = Tx_5548 * i_5650;
            
            for (int64_t i_5652 = 0; i_5652 < Rx_5549; i_5652++) {
                int64_t binop_y_5677 = Tx_5548 * i_5652;
                int64_t ltid_y_5673 = sext_i32_i64(sext_i64_i32(ltid_pre_6379));
                int64_t ltid_x_5674 = sext_i32_i64(sext_i64_i32(ltid_pre_6380));
                int32_t ltid_flat_5672 = local_tid_6369;
                int64_t k_5676 = ltid_y_5673 + binop_y_5675;
                int64_t i_5678 = ltid_x_5674 + binop_y_5677;
                int64_t gtid_5679 = jjj_5573 + i_5678;
                int64_t x_seqdim_idx_5680 = kk_5604 + k_5676;
                bool cond_5681 = slt64(gtid_5679, p_5372);
                float x_elem_5682;
                
                if (cond_5681) {
                    float A_elem_5684;
                    
                    A_elem_5684 = ((__global
                                    float *) yss_mem_6060)[x_seqdim_idx_5680 *
                                                           p_5372 + gtid_5679];
                    x_elem_5682 = A_elem_5684;
                } else {
                    x_elem_5682 = 0.0F;
                }
                
                bool cond_5686 = slt64(k_5676, Tk_5550);
                int64_t x_loc_ind_5687;
                
                if (cond_5686) {
                    int64_t binop_y_5688 = (int64_t) 1 + TxRx_5553;
                    int64_t binop_y_5689 = k_5676 * binop_y_5688;
                    int64_t loc_fi_5690 = i_5678 + binop_y_5689;
                    
                    x_loc_ind_5687 = loc_fi_5690;
                } else {
                    x_loc_ind_5687 = (int64_t) -1;
                }
                if (sle64((int64_t) 0, x_loc_ind_5687) && slt64(x_loc_ind_5687,
                                                                b_loc_szz_5564)) {
                    ((__local float *) color_6343)[x_loc_ind_5687] =
                        x_elem_5682;
                }
                barrier(CLK_LOCAL_MEM_FENCE);
            }
        }
        for (int64_t i_6402 = 0; i_6402 < Ry_5547; i_6402++) {
            for (int64_t i_6403 = 0; i_6403 < Rx_5549; i_6403++) {
                float tmp_6404;
                
                tmp_6404 = mem_param_6103[i_6402 * Rx_5549 + i_6403];
                color_6339[i_6402 * Rx_5549 + i_6403] = tmp_6404;
            }
        }
        
        float ext_mem_6189[Ry_5547 * Rx_5549];
        float ext_mem_unused_6320[Ry_5547 * Rx_5549];
        float mem_param_6160[Ry_5547 * Rx_5549];
        float mem_param_out_6321[Ry_5547 * Rx_5549];
        
        for (int32_t i_3 = 0; i_3 < Ry_5547 * Rx_5549; i_3++)
            mem_param_6160[i_3] = color_6339[i_3];
        for (int32_t i_4 = 0; i_4 < Ry_5547 * Rx_5549; i_4++)
            mem_param_out_6321[i_4] = color_6340[i_4];
        for (int64_t i_5695 = 0; i_5695 < Tk_5550; i_5695++) {
            int64_t binop_y_5743 = i_5695 * binop_y_5742;
            int64_t ltid_y_5723 = sext_i32_i64(sext_i64_i32(ltid_pre_6373));
            int64_t ltid_x_5722 = sext_i32_i64(sext_i64_i32(ltid_pre_6374));
            int32_t ltid_flat_5724 = local_tid_6369;
            float color_6333[Rx_5549];
            float color_6334[Rx_5549];
            int64_t binop_x_5729 = Rx_5549 * ltid_y_5723;
            
            for (int64_t i_5727 = 0; i_5727 < Rx_5549; i_5727++) {
                int64_t binop_x_5730 = i_5727 + binop_x_5729;
                int64_t binop_y_5732 = binop_x_5730 * binop_y_5731;
                int64_t x_loc_ind_5733 = i_5695 + binop_y_5732;
                
                for (int64_t i_6409 = 0; i_6409 < (int64_t) 1; i_6409++) {
                    float tmp_6410;
                    
                    tmp_6410 = ((__local float *) color_6344)[x_loc_ind_5733 +
                                                              i_6409];
                    color_6334[i_5727 + i_6409] = tmp_6410;
                }
            }
            
            int64_t binop_y_5740 = Rx_5549 * ltid_x_5722;
            
            for (int64_t i_5738 = 0; i_5738 < Rx_5549; i_5738++) {
                int64_t binop_x_5741 = i_5738 + binop_y_5740;
                int64_t x_loc_ind_5744 = binop_x_5741 + binop_y_5743;
                
                for (int64_t i_6412 = 0; i_6412 < (int64_t) 1; i_6412++) {
                    float tmp_6413;
                    
                    tmp_6413 = ((__local float *) color_6343)[x_loc_ind_5744 +
                                                              i_6412];
                    color_6333[i_5738 + i_6412] = tmp_6413;
                }
            }
            for (int64_t i_6414 = 0; i_6414 < Rx_5549; i_6414++) {
                float tmp_6415;
                
                tmp_6415 = color_6334[i_6414];
                color_6342[i_6414] = tmp_6415;
            }
            for (int64_t i_6416 = 0; i_6416 < Rx_5549; i_6416++) {
                float tmp_6417;
                
                tmp_6417 = color_6333[i_6416];
                color_6341[i_6416] = tmp_6417;
            }
            barrier(CLK_LOCAL_MEM_FENCE);
            
            int64_t ltid_y_5783 = sext_i32_i64(sext_i64_i32(ltid_pre_6373));
            int64_t ltid_x_5782 = sext_i32_i64(sext_i64_i32(ltid_pre_6374));
            int32_t ltid_flat_5784 = local_tid_6369;
            int64_t binop_y_5795 = Ry_5547 * ltid_y_5783;
            int64_t binop_y_5799 = Rx_5549 * ltid_x_5782;
            
            for (int64_t i_5789 = 0; i_5789 < Ry_5547; i_5789++) {
                int64_t binop_x_5794 = iii_5572 + i_5789;
                int64_t cmpop_x_5796 = binop_x_5794 + binop_y_5795;
                bool binop_x_5797 = slt64(cmpop_x_5796, n_5370);
                
                for (int64_t i_5792 = 0; i_5792 < Rx_5549; i_5792++) {
                    int64_t binop_x_5798 = jjj_5573 + i_5792;
                    int64_t cmpop_x_5800 = binop_x_5798 + binop_y_5799;
                    bool binop_y_5801 = slt64(cmpop_x_5800, p_5372);
                    bool cond_5802 = binop_x_5797 && binop_y_5801;
                    
                    if (cond_5802) {
                        float a_5804;
                        
                        a_5804 = color_6342[i_5789];
                        
                        float b_5805;
                        
                        b_5805 = color_6341[i_5792];
                        
                        float c_5806;
                        
                        c_5806 = mem_param_6160[i_5789 * Rx_5549 + i_5792];
                        
                        float defunc_1_f_res_5809 = a_5804 * b_5805;
                        float defunc_1_op_res_5813 = c_5806 +
                              defunc_1_f_res_5809;
                        
                        mem_param_6160[i_5789 * Rx_5549 + i_5792] =
                            defunc_1_op_res_5813;
                    }
                }
            }
            for (int64_t i_6420 = 0; i_6420 < Ry_5547; i_6420++) {
                for (int64_t i_6421 = 0; i_6421 < Rx_5549; i_6421++) {
                    float tmp_6422;
                    
                    tmp_6422 = mem_param_6160[i_6420 * Rx_5549 + i_6421];
                    mem_param_out_6321[i_6420 * Rx_5549 + i_6421] = tmp_6422;
                }
            }
            barrier(CLK_LOCAL_MEM_FENCE);
            
            float mem_param_tmp_6405[Ry_5547 * Rx_5549];
            
            for (int32_t i_5 = 0; i_5 < Ry_5547 * Rx_5549; i_5++)
                mem_param_tmp_6405[i_5] = mem_param_out_6321[i_5];
            
            float mem_param_out_tmp_6406[Ry_5547 * Rx_5549];
            
            for (int32_t i_6 = 0; i_6 < Ry_5547 * Rx_5549; i_6++)
                mem_param_out_tmp_6406[i_6] = mem_param_6160[i_6];
            for (int32_t i_7 = 0; i_7 < Ry_5547 * Rx_5549; i_7++)
                mem_param_6160[i_7] = mem_param_tmp_6405[i_7];
            for (int32_t i_8 = 0; i_8 < Ry_5547 * Rx_5549; i_8++)
                mem_param_out_6321[i_8] = mem_param_out_tmp_6406[i_8];
        }
        for (int32_t i_9 = 0; i_9 < Ry_5547 * Rx_5549; i_9++)
            ext_mem_6189[i_9] = mem_param_6160[i_9];
        for (int32_t i_10 = 0; i_10 < Ry_5547 * Rx_5549; i_10++)
            ext_mem_unused_6320[i_10] = mem_param_out_6321[i_10];
        
        float mem_param_tmp_6394[Ry_5547 * Rx_5549];
        
        for (int32_t i_11 = 0; i_11 < Ry_5547 * Rx_5549; i_11++)
            mem_param_tmp_6394[i_11] = ext_mem_6189[i_11];
        for (int32_t i_12 = 0; i_12 < Ry_5547 * Rx_5549; i_12++)
            mem_param_6103[i_12] = mem_param_tmp_6394[i_12];
    }
    for (int32_t i_13 = 0; i_13 < Ry_5547 * Rx_5549; i_13++)
        ext_mem_6192[i_13] = mem_param_6103[i_13];
    for (int64_t i_5823 = 0; i_5823 < Rx_5549; i_5823++) {
        int64_t binop_y_5852 = Tx_5548 * i_5823;
        
        for (int64_t i_5825 = 0; i_5825 < tk_div_tx_5551; i_5825++) {
            int64_t binop_y_5850 = Tx_5548 * i_5825;
            int64_t ltid_y_5848 = sext_i32_i64(sext_i64_i32(ltid_pre_6379));
            int64_t ltid_x_5849 = sext_i32_i64(sext_i64_i32(ltid_pre_6380));
            int32_t ltid_flat_5847 = local_tid_6369;
            int64_t k_5851 = ltid_x_5849 + binop_y_5850;
            int64_t i_5853 = ltid_y_5848 + binop_y_5852;
            int64_t gtid_5854 = iii_5572 + i_5853;
            int64_t x_seqdim_idx_5855 = kk_5822 + k_5851;
            bool binop_x_5856 = slt64(gtid_5854, n_5370);
            bool binop_y_5857 = slt64(x_seqdim_idx_5855, m_5371);
            bool cond_5858 = binop_x_5856 && binop_y_5857;
            float x_elem_5859;
            
            if (cond_5858) {
                float A_elem_5861;
                
                A_elem_5861 = ((__global float *) xss_mem_6059)[gtid_5854 *
                                                                m_5371 +
                                                                x_seqdim_idx_5855];
                x_elem_5859 = A_elem_5861;
            } else {
                x_elem_5859 = 0.0F;
            }
            
            bool cond_5863 = slt64(k_5851, Tk_5550);
            int64_t x_loc_ind_5864;
            
            if (cond_5863) {
                int64_t binop_y_5865 = (int64_t) 1 + Tk_5550;
                int64_t binop_y_5866 = i_5853 * binop_y_5865;
                int64_t loc_fi_5867 = k_5851 + binop_y_5866;
                
                x_loc_ind_5864 = loc_fi_5867;
            } else {
                x_loc_ind_5864 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, x_loc_ind_5864) && slt64(x_loc_ind_5864,
                                                            a_loc_szz_5559)) {
                ((__local float *) color_6344)[x_loc_ind_5864] = x_elem_5859;
            }
            barrier(CLK_LOCAL_MEM_FENCE);
        }
    }
    for (int64_t i_5872 = 0; i_5872 < tk_div_tx_5551; i_5872++) {
        int64_t binop_y_5899 = Tx_5548 * i_5872;
        
        for (int64_t i_5874 = 0; i_5874 < Rx_5549; i_5874++) {
            int64_t binop_y_5901 = Tx_5548 * i_5874;
            int64_t ltid_y_5897 = sext_i32_i64(sext_i64_i32(ltid_pre_6379));
            int64_t ltid_x_5898 = sext_i32_i64(sext_i64_i32(ltid_pre_6380));
            int32_t ltid_flat_5896 = local_tid_6369;
            int64_t k_5900 = ltid_y_5897 + binop_y_5899;
            int64_t i_5902 = ltid_x_5898 + binop_y_5901;
            int64_t gtid_5903 = jjj_5573 + i_5902;
            int64_t x_seqdim_idx_5904 = kk_5822 + k_5900;
            bool binop_x_5905 = slt64(gtid_5903, p_5372);
            bool binop_y_5906 = slt64(x_seqdim_idx_5904, m_5371);
            bool cond_5907 = binop_x_5905 && binop_y_5906;
            float x_elem_5908;
            
            if (cond_5907) {
                float A_elem_5910;
                
                A_elem_5910 = ((__global
                                float *) yss_mem_6060)[x_seqdim_idx_5904 *
                                                       p_5372 + gtid_5903];
                x_elem_5908 = A_elem_5910;
            } else {
                x_elem_5908 = 0.0F;
            }
            
            bool cond_5912 = slt64(k_5900, Tk_5550);
            int64_t x_loc_ind_5913;
            
            if (cond_5912) {
                int64_t binop_y_5914 = (int64_t) 1 + TxRx_5553;
                int64_t binop_y_5915 = k_5900 * binop_y_5914;
                int64_t loc_fi_5916 = i_5902 + binop_y_5915;
                
                x_loc_ind_5913 = loc_fi_5916;
            } else {
                x_loc_ind_5913 = (int64_t) -1;
            }
            if (sle64((int64_t) 0, x_loc_ind_5913) && slt64(x_loc_ind_5913,
                                                            b_loc_szz_5564)) {
                ((__local float *) color_6343)[x_loc_ind_5913] = x_elem_5908;
            }
            barrier(CLK_LOCAL_MEM_FENCE);
        }
    }
    for (int64_t i_6427 = 0; i_6427 < Ry_5547; i_6427++) {
        for (int64_t i_6428 = 0; i_6428 < Rx_5549; i_6428++) {
            float tmp_6429;
            
            tmp_6429 = ext_mem_6192[i_6427 * Rx_5549 + i_6428];
            color_6338[i_6427 * Rx_5549 + i_6428] = tmp_6429;
        }
    }
    
    float ext_mem_6273[Ry_5547 * Rx_5549];
    float ext_mem_unused_6328[Ry_5547 * Rx_5549];
    float mem_param_6243[Ry_5547 * Rx_5549];
    float mem_param_out_6329[Ry_5547 * Rx_5549];
    
    for (int32_t i_14 = 0; i_14 < Ry_5547 * Rx_5549; i_14++)
        mem_param_6243[i_14] = color_6338[i_14];
    for (int32_t i_15 = 0; i_15 < Ry_5547 * Rx_5549; i_15++)
        mem_param_out_6329[i_15] = color_6339[i_15];
    for (int64_t i_5921 = 0; i_5921 < Tk_5550; i_5921++) {
        int64_t cmpop_x_5923 = kk_5822 + i_5921;
        bool cond_5924 = slt64(cmpop_x_5923, m_5371);
        
        if (cond_5924) {
            int64_t binop_y_5959 = (int64_t) 1 + Tk_5550;
            int64_t binop_y_5970 = (int64_t) 1 + TxRx_5553;
            int64_t binop_y_5971 = i_5921 * binop_y_5970;
            int64_t bytes_6245 = (int64_t) 4 * Rx_5549;
            int64_t ltid_y_5951 = sext_i32_i64(sext_i64_i32(ltid_pre_6373));
            int64_t ltid_x_5950 = sext_i32_i64(sext_i64_i32(ltid_pre_6374));
            int32_t ltid_flat_5952 = local_tid_6369;
            float color_6335[Rx_5549];
            float color_6336[Rx_5549];
            int64_t binop_x_5957 = Rx_5549 * ltid_y_5951;
            
            for (int64_t i_5955 = 0; i_5955 < Rx_5549; i_5955++) {
                int64_t binop_x_5958 = i_5955 + binop_x_5957;
                int64_t binop_y_5960 = binop_x_5958 * binop_y_5959;
                int64_t x_loc_ind_5961 = i_5921 + binop_y_5960;
                
                for (int64_t i_6434 = 0; i_6434 < (int64_t) 1; i_6434++) {
                    float tmp_6435;
                    
                    tmp_6435 = ((__local float *) color_6344)[x_loc_ind_5961 +
                                                              i_6434];
                    color_6336[i_5955 + i_6434] = tmp_6435;
                }
            }
            
            int64_t binop_y_5968 = Rx_5549 * ltid_x_5950;
            
            for (int64_t i_5966 = 0; i_5966 < Rx_5549; i_5966++) {
                int64_t binop_x_5969 = i_5966 + binop_y_5968;
                int64_t x_loc_ind_5972 = binop_x_5969 + binop_y_5971;
                
                for (int64_t i_6437 = 0; i_6437 < (int64_t) 1; i_6437++) {
                    float tmp_6438;
                    
                    tmp_6438 = ((__local float *) color_6343)[x_loc_ind_5972 +
                                                              i_6437];
                    color_6335[i_5966 + i_6437] = tmp_6438;
                }
            }
            for (int64_t i_6439 = 0; i_6439 < Rx_5549; i_6439++) {
                float tmp_6440;
                
                tmp_6440 = color_6336[i_6439];
                color_6342[i_6439] = tmp_6440;
            }
            for (int64_t i_6441 = 0; i_6441 < Rx_5549; i_6441++) {
                float tmp_6442;
                
                tmp_6442 = color_6335[i_6441];
                color_6341[i_6441] = tmp_6442;
            }
            barrier(CLK_LOCAL_MEM_FENCE);
            
            int64_t ltid_y_6011 = sext_i32_i64(sext_i64_i32(ltid_pre_6373));
            int64_t ltid_x_6010 = sext_i32_i64(sext_i64_i32(ltid_pre_6374));
            int32_t ltid_flat_6012 = local_tid_6369;
            int64_t binop_y_6023 = Ry_5547 * ltid_y_6011;
            int64_t binop_y_6027 = Rx_5549 * ltid_x_6010;
            
            for (int64_t i_6017 = 0; i_6017 < Ry_5547; i_6017++) {
                int64_t binop_x_6022 = iii_5572 + i_6017;
                int64_t cmpop_x_6024 = binop_x_6022 + binop_y_6023;
                bool binop_x_6025 = slt64(cmpop_x_6024, n_5370);
                
                for (int64_t i_6020 = 0; i_6020 < Rx_5549; i_6020++) {
                    int64_t binop_x_6026 = jjj_5573 + i_6020;
                    int64_t cmpop_x_6028 = binop_x_6026 + binop_y_6027;
                    bool binop_y_6029 = slt64(cmpop_x_6028, p_5372);
                    bool cond_6030 = binop_x_6025 && binop_y_6029;
                    
                    if (cond_6030) {
                        float a_6032;
                        
                        a_6032 = color_6342[i_6017];
                        
                        float b_6033;
                        
                        b_6033 = color_6341[i_6020];
                        
                        float c_6034;
                        
                        c_6034 = mem_param_6243[i_6017 * Rx_5549 + i_6020];
                        
                        float defunc_1_f_res_6037 = a_6032 * b_6033;
                        float defunc_1_op_res_6041 = c_6034 +
                              defunc_1_f_res_6037;
                        
                        mem_param_6243[i_6017 * Rx_5549 + i_6020] =
                            defunc_1_op_res_6041;
                    }
                }
            }
            for (int64_t i_6445 = 0; i_6445 < Ry_5547; i_6445++) {
                for (int64_t i_6446 = 0; i_6446 < Rx_5549; i_6446++) {
                    float tmp_6447;
                    
                    tmp_6447 = mem_param_6243[i_6445 * Rx_5549 + i_6446];
                    color_6340[i_6445 * Rx_5549 + i_6446] = tmp_6447;
                }
            }
            barrier(CLK_LOCAL_MEM_FENCE);
            for (int64_t i_6448 = 0; i_6448 < Ry_5547; i_6448++) {
                for (int64_t i_6449 = 0; i_6449 < Rx_5549; i_6449++) {
                    float tmp_6450;
                    
                    tmp_6450 = color_6340[i_6448 * Rx_5549 + i_6449];
                    mem_param_out_6329[i_6448 * Rx_5549 + i_6449] = tmp_6450;
                }
            }
        } else {
            for (int64_t i_6451 = 0; i_6451 < Ry_5547; i_6451++) {
                for (int64_t i_6452 = 0; i_6452 < Rx_5549; i_6452++) {
                    float tmp_6453;
                    
                    tmp_6453 = mem_param_6243[i_6451 * Rx_5549 + i_6452];
                    mem_param_out_6329[i_6451 * Rx_5549 + i_6452] = tmp_6453;
                }
            }
        }
        
        float mem_param_tmp_6430[Ry_5547 * Rx_5549];
        
        for (int32_t i_16 = 0; i_16 < Ry_5547 * Rx_5549; i_16++)
            mem_param_tmp_6430[i_16] = mem_param_out_6329[i_16];
        
        float mem_param_out_tmp_6431[Ry_5547 * Rx_5549];
        
        for (int32_t i_17 = 0; i_17 < Ry_5547 * Rx_5549; i_17++)
            mem_param_out_tmp_6431[i_17] = mem_param_6243[i_17];
        for (int32_t i_18 = 0; i_18 < Ry_5547 * Rx_5549; i_18++)
            mem_param_6243[i_18] = mem_param_tmp_6430[i_18];
        for (int32_t i_19 = 0; i_19 < Ry_5547 * Rx_5549; i_19++)
            mem_param_out_6329[i_19] = mem_param_out_tmp_6431[i_19];
    }
    for (int32_t i_20 = 0; i_20 < Ry_5547 * Rx_5549; i_20++)
        ext_mem_6273[i_20] = mem_param_6243[i_20];
    for (int32_t i_21 = 0; i_21 < Ry_5547 * Rx_5549; i_21++)
        ext_mem_unused_6328[i_21] = mem_param_out_6329[i_21];
    
    int64_t slice_6456 = Tx_5548;
    int64_t slice_6457 = Ty_5546 * slice_6456;
    int64_t reg_tile_i_6454 = squot64(sext_i32_i64(local_tid_6369), slice_6456);
    int64_t remnant_6458 = sext_i32_i64(local_tid_6369) - reg_tile_i_6454 *
            slice_6456;
    int64_t reg_tile_i_6455 = remnant_6458;
    int64_t remnant_6459 = remnant_6458 - reg_tile_i_6455;
    int64_t tile_dim_start_6460 = Ry_5547 * (Ty_5546 * gid_y_5569 +
                                             reg_tile_i_6454);
    int64_t tile_dim_start_6461 = Rx_5549 * (Tx_5548 * gid_x_5570 +
                                             reg_tile_i_6455);
    
    for (int64_t nest_i_6462 = 0; nest_i_6462 < Ry_5547; nest_i_6462++) {
        for (int64_t nest_i_6463 = 0; nest_i_6463 < Rx_5549; nest_i_6463++) {
            if (slt64(tile_dim_start_6460 + nest_i_6462, n_5370) &&
                slt64(tile_dim_start_6461 + nest_i_6463, p_5372)) {
                float tmp_6464;
                
                tmp_6464 = ext_mem_6273[nest_i_6462 * Rx_5549 + nest_i_6463];
                ((__global float *) mem_6277)[(tile_dim_start_6460 +
                                               nest_i_6462) * p_5372 +
                                              (tile_dim_start_6461 +
                                               nest_i_6463)] = tmp_6464;
            }
        }
    }
    
  error_9:
    return;
    #undef Ty_5546
    #undef Ry_5547
    #undef Tx_5548
    #undef Rx_5549
    #undef Tk_5550
    #undef tk_div_tx_5551
    #undef TxRx_5553
    #undef TyRy_5554
    #undef a_loc_szz_5559
    #undef b_loc_szz_5564
    #undef binop_y_5731
    #undef binop_y_5742
}
__kernel void mainzisegred_large_5525(__global int *global_failure,
                                      uint sync_arr_mem_6510_backing_offset_0,
                                      uint red_arr_mem_6508_backing_offset_1,
                                      int64_t n_5370, int64_t m_5371,
                                      int64_t p_5372, int64_t num_groups_5519,
                                      int64_t groups_per_segment_6494,
                                      int64_t elements_per_thread_6495,
                                      int64_t virt_num_groups_6496,
                                      int64_t threads_per_segment_6498, __global
                                      unsigned char *xss_mem_6059, __global
                                      unsigned char *mem_6280, __global
                                      unsigned char *mem_6285, __global
                                      unsigned char *segred_tmp_mem_6499,
                                      __global
                                      unsigned char *mainzicounter_mem_6501)
{
    #define segred_group_sizze_5518 (mainzisegred_group_sizze_5455)
    
    const int block_dim0 = 0;
    const int block_dim1 = 1;
    const int block_dim2 = 2;
    volatile unsigned char *sync_arr_mem_6510_backing_1 =
                           &shared_mem[sync_arr_mem_6510_backing_offset_0];
    volatile unsigned char *red_arr_mem_6508_backing_0 =
                           &shared_mem[red_arr_mem_6508_backing_offset_1];
    
    if (*global_failure >= 0)
        return;
    
    int32_t global_tid_6503;
    int32_t local_tid_6504;
    int64_t group_sizze_6507;
    int32_t wave_sizze_6506;
    int32_t group_tid_6505;
    
    global_tid_6503 = get_global_id(0);
    local_tid_6504 = get_local_id(0);
    group_sizze_6507 = get_local_size(0);
    wave_sizze_6506 = LOCKSTEP_WIDTH;
    group_tid_6505 = get_group_id(0);
    
    int32_t phys_tid_5525 = global_tid_6503;
    __local unsigned char *red_arr_mem_6508;
    
    red_arr_mem_6508 = (__local unsigned char *) red_arr_mem_6508_backing_0;
    
    __local unsigned char *sync_arr_mem_6510;
    
    sync_arr_mem_6510 = (__local unsigned char *) sync_arr_mem_6510_backing_1;
    
    int32_t phys_group_id_6512;
    
    phys_group_id_6512 = get_group_id(0);
    for (int32_t i_6513 = 0; i_6513 <
         sdiv_up32(sext_i64_i32(virt_num_groups_6496) - phys_group_id_6512,
                   sext_i64_i32(num_groups_5519)); i_6513++) {
        int32_t virt_group_id_6514 = phys_group_id_6512 + i_6513 *
                sext_i64_i32(num_groups_5519);
        int32_t flat_segment_id_6515 = squot32(virt_group_id_6514,
                                               sext_i64_i32(groups_per_segment_6494));
        int64_t global_tid_6516 = srem64(sext_i32_i64(virt_group_id_6514) *
                                         segred_group_sizze_5518 +
                                         sext_i32_i64(local_tid_6504),
                                         segred_group_sizze_5518 *
                                         groups_per_segment_6494);
        int64_t slice_6517 = p_5372;
        int64_t slice_6518 = n_5370 * slice_6517;
        int64_t gtid_5522 = squot64(sext_i32_i64(flat_segment_id_6515),
                                    slice_6517);
        int64_t remnant_6519 = sext_i32_i64(flat_segment_id_6515) - gtid_5522 *
                slice_6517;
        int64_t gtid_5523 = remnant_6519;
        int64_t remnant_6520 = remnant_6519 - gtid_5523;
        int64_t gtid_5524;
        float x_acc_6521;
        int64_t chunk_sizze_6522 = smin64(elements_per_thread_6495,
                                          sdiv_up64(m_5371 - global_tid_6516,
                                                    threads_per_segment_6498));
        float x_5526;
        float x_5527;
        
        // neutral-initialise the accumulators
        {
            x_acc_6521 = 0.0F;
        }
        for (int64_t i_6526 = 0; i_6526 < chunk_sizze_6522; i_6526++) {
            gtid_5524 = global_tid_6516 + threads_per_segment_6498 * i_6526;
            // apply map function
            {
                float x_5531;
                
                x_5531 = ((__global float *) xss_mem_6059)[gtid_5522 * m_5371 +
                                                           gtid_5524];
                
                float x_5532;
                
                x_5532 = ((__global float *) mem_6280)[gtid_5523 * m_5371 +
                                                       gtid_5524];
                
                float defunc_1_f_res_5533 = x_5531 * x_5532;
                
                // save map-out results
                { }
                // load accumulator
                {
                    x_5526 = x_acc_6521;
                }
                // load new values
                {
                    x_5527 = defunc_1_f_res_5533;
                }
                // apply reduction operator
                {
                    float defunc_1_op_res_5528 = x_5526 + x_5527;
                    
                    // store in accumulator
                    {
                        x_acc_6521 = defunc_1_op_res_5528;
                    }
                }
            }
        }
        // to reduce current chunk, first store our result in memory
        {
            x_5526 = x_acc_6521;
            ((__local float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                x_5526;
        }
        barrier(CLK_LOCAL_MEM_FENCE);
        
        int32_t offset_6527;
        int32_t skip_waves_6528 = 1;
        float x_6523;
        float x_6524;
        
        offset_6527 = 0;
        // participating threads read initial accumulator
        {
            if (slt32(local_tid_6504, sext_i64_i32(segred_group_sizze_5518))) {
                x_6523 = ((__local
                           float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                      offset_6527)];
            }
        }
        offset_6527 = 1;
        while (slt32(offset_6527, wave_sizze_6506)) {
            if (slt32(local_tid_6504 + offset_6527,
                      sext_i64_i32(segred_group_sizze_5518)) &&
                ((local_tid_6504 - squot32(local_tid_6504, wave_sizze_6506) *
                  wave_sizze_6506) & (2 * offset_6527 - 1)) == 0) {
                // read array element
                {
                    x_6524 = ((volatile __local
                               float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                          offset_6527)];
                }
                // apply reduction operation
                {
                    float defunc_1_op_res_6525 = x_6523 + x_6524;
                    
                    x_6523 = defunc_1_op_res_6525;
                }
                // write result of operation
                {
                    ((volatile __local
                      float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                        x_6523;
                }
            }
            offset_6527 *= 2;
        }
        while (slt32(skip_waves_6528,
                     squot32(sext_i64_i32(segred_group_sizze_5518) +
                             wave_sizze_6506 - 1, wave_sizze_6506))) {
            barrier(CLK_LOCAL_MEM_FENCE);
            offset_6527 = skip_waves_6528 * wave_sizze_6506;
            if (slt32(local_tid_6504 + offset_6527,
                      sext_i64_i32(segred_group_sizze_5518)) &&
                ((local_tid_6504 - squot32(local_tid_6504, wave_sizze_6506) *
                  wave_sizze_6506) == 0 && (squot32(local_tid_6504,
                                                    wave_sizze_6506) & (2 *
                                                                        skip_waves_6528 -
                                                                        1)) ==
                 0)) {
                // read array element
                {
                    x_6524 = ((__local
                               float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                          offset_6527)];
                }
                // apply reduction operation
                {
                    float defunc_1_op_res_6525 = x_6523 + x_6524;
                    
                    x_6523 = defunc_1_op_res_6525;
                }
                // write result of operation
                {
                    ((__local
                      float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                        x_6523;
                }
            }
            skip_waves_6528 *= 2;
        }
        barrier(CLK_LOCAL_MEM_FENCE);
        // first thread saves the result in accumulator
        {
            if (sext_i32_i64(local_tid_6504) == (int64_t) 0) {
                x_acc_6521 = x_6523;
            }
        }
        if (groups_per_segment_6494 == (int64_t) 1) {
            // first thread in group saves final result to memory
            {
                if (local_tid_6504 == 0) {
                    ((__global float *) mem_6285)[gtid_5522 * p_5372 +
                                                  gtid_5523] = x_acc_6521;
                }
            }
        } else {
            int32_t old_counter_6529;
            
            // first thread in group saves group result to global memory
            {
                if (local_tid_6504 == 0) {
                    ((__global
                      float *) segred_tmp_mem_6499)[sext_i32_i64(virt_group_id_6514)] =
                        x_acc_6521;
                    mem_fence_global();
                    old_counter_6529 =
                        atomic_add_i32_global(&((volatile __global
                                                 int *) mainzicounter_mem_6501)[sext_i32_i64(srem32(flat_segment_id_6515,
                                                                                                    10240))],
                                              (int) 1);
                    ((__local bool *) sync_arr_mem_6510)[(int64_t) 0] =
                        old_counter_6529 == groups_per_segment_6494 -
                        (int64_t) 1;
                }
            }
            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
            
            bool is_last_group_6530;
            
            is_last_group_6530 = ((__local
                                   bool *) sync_arr_mem_6510)[(int64_t) 0];
            if (is_last_group_6530) {
                if (local_tid_6504 == 0) {
                    old_counter_6529 =
                        atomic_add_i32_global(&((volatile __global
                                                 int *) mainzicounter_mem_6501)[sext_i32_i64(srem32(flat_segment_id_6515,
                                                                                                    10240))],
                                              (int) ((int64_t) 0 -
                                                     groups_per_segment_6494));
                }
                // read in the per-group-results
                {
                    int64_t read_per_thread_6531 =
                            sdiv_up64(groups_per_segment_6494,
                                      segred_group_sizze_5518);
                    
                    x_5526 = 0.0F;
                    for (int64_t i_6532 = 0; i_6532 < read_per_thread_6531;
                         i_6532++) {
                        int64_t group_res_id_6533 =
                                sext_i32_i64(local_tid_6504) *
                                read_per_thread_6531 + i_6532;
                        int64_t index_of_group_res_6534 =
                                sext_i32_i64(flat_segment_id_6515) *
                                groups_per_segment_6494 + group_res_id_6533;
                        
                        if (slt64(group_res_id_6533, groups_per_segment_6494)) {
                            x_5527 = ((__global
                                       float *) segred_tmp_mem_6499)[index_of_group_res_6534];
                            
                            float defunc_1_op_res_5528 = x_5526 + x_5527;
                            
                            x_5526 = defunc_1_op_res_5528;
                        }
                    }
                }
                ((__local
                  float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                    x_5526;
                barrier(CLK_LOCAL_MEM_FENCE);
                // reduce the per-group results
                {
                    int32_t offset_6535;
                    int32_t skip_waves_6536 = 1;
                    float x_6523;
                    float x_6524;
                    
                    offset_6535 = 0;
                    // participating threads read initial accumulator
                    {
                        if (slt32(local_tid_6504,
                                  sext_i64_i32(segred_group_sizze_5518))) {
                            x_6523 = ((__local
                                       float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                                  offset_6535)];
                        }
                    }
                    offset_6535 = 1;
                    while (slt32(offset_6535, wave_sizze_6506)) {
                        if (slt32(local_tid_6504 + offset_6535,
                                  sext_i64_i32(segred_group_sizze_5518)) &&
                            ((local_tid_6504 - squot32(local_tid_6504,
                                                       wave_sizze_6506) *
                              wave_sizze_6506) & (2 * offset_6535 - 1)) == 0) {
                            // read array element
                            {
                                x_6524 = ((volatile __local
                                           float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                                      offset_6535)];
                            }
                            // apply reduction operation
                            {
                                float defunc_1_op_res_6525 = x_6523 + x_6524;
                                
                                x_6523 = defunc_1_op_res_6525;
                            }
                            // write result of operation
                            {
                                ((volatile __local
                                  float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                                    x_6523;
                            }
                        }
                        offset_6535 *= 2;
                    }
                    while (slt32(skip_waves_6536,
                                 squot32(sext_i64_i32(segred_group_sizze_5518) +
                                         wave_sizze_6506 - 1,
                                         wave_sizze_6506))) {
                        barrier(CLK_LOCAL_MEM_FENCE);
                        offset_6535 = skip_waves_6536 * wave_sizze_6506;
                        if (slt32(local_tid_6504 + offset_6535,
                                  sext_i64_i32(segred_group_sizze_5518)) &&
                            ((local_tid_6504 - squot32(local_tid_6504,
                                                       wave_sizze_6506) *
                              wave_sizze_6506) == 0 && (squot32(local_tid_6504,
                                                                wave_sizze_6506) &
                                                        (2 * skip_waves_6536 -
                                                         1)) == 0)) {
                            // read array element
                            {
                                x_6524 = ((__local
                                           float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504 +
                                                                      offset_6535)];
                            }
                            // apply reduction operation
                            {
                                float defunc_1_op_res_6525 = x_6523 + x_6524;
                                
                                x_6523 = defunc_1_op_res_6525;
                            }
                            // write result of operation
                            {
                                ((__local
                                  float *) red_arr_mem_6508)[sext_i32_i64(local_tid_6504)] =
                                    x_6523;
                            }
                        }
                        skip_waves_6536 *= 2;
                    }
                    // and back to memory with the final result
                    {
                        if (local_tid_6504 == 0) {
                            ((__global float *) mem_6285)[gtid_5522 * p_5372 +
                                                          gtid_5523] = x_6523;
                        }
                    }
                }
            }
        }
        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
    }
    
  error_1:
    return;
    #undef segred_group_sizze_5518
}
__kernel void mainzisegred_small_5525(__global int *global_failure,
                                      uint red_arr_mem_6472_backing_offset_0,
                                      int64_t n_5370, int64_t m_5371,
                                      int64_t p_5372, int64_t num_groups_5519,
                                      int64_t segment_sizze_nonzzero_6465,
                                      __global unsigned char *xss_mem_6059,
                                      __global unsigned char *mem_6280, __global
                                      unsigned char *mem_6285)
{
    #define segred_group_sizze_5518 (mainzisegred_group_sizze_5455)
    
    const int block_dim0 = 0;
    const int block_dim1 = 1;
    const int block_dim2 = 2;
    volatile unsigned char *red_arr_mem_6472_backing_0 =
                           &shared_mem[red_arr_mem_6472_backing_offset_0];
    
    if (*global_failure >= 0)
        return;
    
    int32_t global_tid_6467;
    int32_t local_tid_6468;
    int64_t group_sizze_6471;
    int32_t wave_sizze_6470;
    int32_t group_tid_6469;
    
    global_tid_6467 = get_global_id(0);
    local_tid_6468 = get_local_id(0);
    group_sizze_6471 = get_local_size(0);
    wave_sizze_6470 = LOCKSTEP_WIDTH;
    group_tid_6469 = get_group_id(0);
    
    int32_t phys_tid_5525 = global_tid_6467;
    __local unsigned char *red_arr_mem_6472;
    
    red_arr_mem_6472 = (__local unsigned char *) red_arr_mem_6472_backing_0;
    
    int32_t phys_group_id_6474;
    
    phys_group_id_6474 = get_group_id(0);
    for (int32_t i_6475 = 0; i_6475 < sdiv_up32(sext_i64_i32(sdiv_up64(n_5370 *
                                                                       p_5372,
                                                                       squot64(segred_group_sizze_5518,
                                                                               segment_sizze_nonzzero_6465))) -
                                                phys_group_id_6474,
                                                sext_i64_i32(num_groups_5519));
         i_6475++) {
        int32_t virt_group_id_6476 = phys_group_id_6474 + i_6475 *
                sext_i64_i32(num_groups_5519);
        int64_t slice_6477 = p_5372;
        int64_t slice_6478 = n_5370 * slice_6477;
        int64_t gtid_5522 = squot64(squot64(sext_i32_i64(local_tid_6468),
                                            segment_sizze_nonzzero_6465) +
                                    sext_i32_i64(virt_group_id_6476) *
                                    squot64(segred_group_sizze_5518,
                                            segment_sizze_nonzzero_6465),
                                    slice_6477);
        int64_t remnant_6479 = squot64(sext_i32_i64(local_tid_6468),
                                       segment_sizze_nonzzero_6465) +
                sext_i32_i64(virt_group_id_6476) *
                squot64(segred_group_sizze_5518, segment_sizze_nonzzero_6465) -
                gtid_5522 * slice_6477;
        int64_t gtid_5523 = remnant_6479;
        int64_t remnant_6480 = remnant_6479 - gtid_5523;
        int64_t gtid_5524 = srem64(sext_i32_i64(local_tid_6468), m_5371);
        
        // apply map function if in bounds
        {
            if (slt64((int64_t) 0, m_5371) && ((slt64(gtid_5522, n_5370) &&
                                                slt64(gtid_5523, p_5372)) &&
                                               slt64(sext_i32_i64(local_tid_6468),
                                                     m_5371 *
                                                     squot64(segred_group_sizze_5518,
                                                             segment_sizze_nonzzero_6465)))) {
                float x_5531;
                
                x_5531 = ((__global float *) xss_mem_6059)[gtid_5522 * m_5371 +
                                                           gtid_5524];
                
                float x_5532;
                
                x_5532 = ((__global float *) mem_6280)[gtid_5523 * m_5371 +
                                                       gtid_5524];
                
                float defunc_1_f_res_5533 = x_5531 * x_5532;
                
                // save map-out results
                { }
                // save results to be reduced
                {
                    ((__local
                      float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                        defunc_1_f_res_5533;
                }
            } else {
                ((__local
                  float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                    0.0F;
            }
        }
        barrier(CLK_LOCAL_MEM_FENCE);
        if (slt64((int64_t) 0, m_5371)) {
            // perform segmented scan to imitate reduction
            {
                float x_5526;
                float x_5527;
                float x_6481;
                float x_6482;
                bool ltid_in_bounds_6484 = slt64(sext_i32_i64(local_tid_6468),
                                                 m_5371 *
                                                 squot64(segred_group_sizze_5518,
                                                         segment_sizze_nonzzero_6465));
                int32_t skip_threads_6485;
                
                // read input for in-block scan
                {
                    if (ltid_in_bounds_6484) {
                        x_5527 = ((volatile __local
                                   float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)];
                        if ((local_tid_6468 - squot32(local_tid_6468, 32) *
                             32) == 0) {
                            x_5526 = x_5527;
                        }
                    }
                }
                // in-block scan (hopefully no barriers needed)
                {
                    skip_threads_6485 = 1;
                    while (slt32(skip_threads_6485, 32)) {
                        bool thread_active_6486 = sle32(skip_threads_6485,
                                                        local_tid_6468 -
                                                        squot32(local_tid_6468,
                                                                32) * 32) &&
                             ltid_in_bounds_6484;
                        
                        if (thread_active_6486) {
                            // read operands
                            {
                                x_5526 = ((volatile __local
                                           float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468) -
                                                                      sext_i32_i64(skip_threads_6485)];
                            }
                        }
                        // perform operation
                        {
                            bool inactive_6487 =
                                 slt64(srem64(sext_i32_i64(local_tid_6468),
                                              m_5371),
                                       sext_i32_i64(local_tid_6468) -
                                       sext_i32_i64(local_tid_6468 -
                                       skip_threads_6485));
                            
                            if (thread_active_6486 && inactive_6487) {
                                x_5526 = x_5527;
                            }
                            if (thread_active_6486) {
                                if (!inactive_6487) {
                                    float defunc_1_op_res_5528 = x_5526 +
                                          x_5527;
                                    
                                    x_5526 = defunc_1_op_res_5528;
                                }
                            }
                        }
                        if (sle32(wave_sizze_6470, skip_threads_6485)) {
                            barrier(CLK_LOCAL_MEM_FENCE);
                        }
                        if (thread_active_6486) {
                            // write result
                            {
                                ((volatile __local
                                  float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                                    x_5526;
                                x_5527 = x_5526;
                            }
                        }
                        if (sle32(wave_sizze_6470, skip_threads_6485)) {
                            barrier(CLK_LOCAL_MEM_FENCE);
                        }
                        skip_threads_6485 *= 2;
                    }
                }
                barrier(CLK_LOCAL_MEM_FENCE);
                // last thread of block 'i' writes its result to offset 'i'
                {
                    if ((local_tid_6468 - squot32(local_tid_6468, 32) * 32) ==
                        31 && ltid_in_bounds_6484) {
                        ((volatile __local
                          float *) red_arr_mem_6472)[sext_i32_i64(squot32(local_tid_6468,
                                                                          32))] =
                            x_5526;
                    }
                }
                barrier(CLK_LOCAL_MEM_FENCE);
                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'
                {
                    int32_t skip_threads_6488;
                    
                    // read input for in-block scan
                    {
                        if (squot32(local_tid_6468, 32) == 0 &&
                            ltid_in_bounds_6484) {
                            x_6482 = ((volatile __local
                                       float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)];
                            if ((local_tid_6468 - squot32(local_tid_6468, 32) *
                                 32) == 0) {
                                x_6481 = x_6482;
                            }
                        }
                    }
                    // in-block scan (hopefully no barriers needed)
                    {
                        skip_threads_6488 = 1;
                        while (slt32(skip_threads_6488, 32)) {
                            bool thread_active_6489 = sle32(skip_threads_6488,
                                                            local_tid_6468 -
                                                            squot32(local_tid_6468,
                                                                    32) * 32) &&
                                 (squot32(local_tid_6468, 32) == 0 &&
                                  ltid_in_bounds_6484);
                            
                            if (thread_active_6489) {
                                // read operands
                                {
                                    x_6481 = ((volatile __local
                                               float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468) -
                                                                          sext_i32_i64(skip_threads_6488)];
                                }
                            }
                            // perform operation
                            {
                                bool inactive_6490 =
                                     slt64(srem64(sext_i32_i64(local_tid_6468 *
                                                  32 + 32 - 1), m_5371),
                                           sext_i32_i64(local_tid_6468 * 32 +
                                           32 - 1) -
                                           sext_i32_i64((local_tid_6468 -
                                                         skip_threads_6488) *
                                           32 + 32 - 1));
                                
                                if (thread_active_6489 && inactive_6490) {
                                    x_6481 = x_6482;
                                }
                                if (thread_active_6489) {
                                    if (!inactive_6490) {
                                        float defunc_1_op_res_6483 = x_6481 +
                                              x_6482;
                                        
                                        x_6481 = defunc_1_op_res_6483;
                                    }
                                }
                            }
                            if (sle32(wave_sizze_6470, skip_threads_6488)) {
                                barrier(CLK_LOCAL_MEM_FENCE);
                            }
                            if (thread_active_6489) {
                                // write result
                                {
                                    ((volatile __local
                                      float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                                        x_6481;
                                    x_6482 = x_6481;
                                }
                            }
                            if (sle32(wave_sizze_6470, skip_threads_6488)) {
                                barrier(CLK_LOCAL_MEM_FENCE);
                            }
                            skip_threads_6488 *= 2;
                        }
                    }
                }
                barrier(CLK_LOCAL_MEM_FENCE);
                
                bool no_carry_in_6491 = squot32(local_tid_6468, 32) == 0 ||
                     !ltid_in_bounds_6484;
                
                // carry-in for every block except the first
                {
                    // read operands
                    {
                        if (!no_carry_in_6491) {
                            x_5527 = x_5526;
                            x_5526 = ((__local
                                       float *) red_arr_mem_6472)[sext_i32_i64(squot32(local_tid_6468,
                                                                                       32)) -
                                                                  (int64_t) 1];
                        }
                    }
                    // perform operation
                    {
                        bool inactive_6492 =
                             slt64(srem64(sext_i32_i64(local_tid_6468), m_5371),
                                   sext_i32_i64(local_tid_6468) -
                                   sext_i32_i64(squot32(local_tid_6468, 32) *
                                   32 - 1));
                        
                        if (!no_carry_in_6491) {
                            if (inactive_6492) {
                                x_5526 = x_5527;
                            }
                        }
                        if (!no_carry_in_6491) {
                            if (!inactive_6492) {
                                float defunc_1_op_res_5528 = x_5526 + x_5527;
                                
                                x_5526 = defunc_1_op_res_5528;
                            }
                        }
                    }
                    // write final result
                    {
                        if (!no_carry_in_6491) {
                            ((__local
                              float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                                x_5526;
                        }
                    }
                }
                barrier(CLK_LOCAL_MEM_FENCE);
                // restore correct values for first block
                {
                    if (squot32(local_tid_6468, 32) == 0 &&
                        ltid_in_bounds_6484) {
                        ((__local
                          float *) red_arr_mem_6472)[sext_i32_i64(local_tid_6468)] =
                            x_5527;
                    }
                }
                barrier(CLK_LOCAL_MEM_FENCE);
            }
        }
        barrier(CLK_LOCAL_MEM_FENCE);
        // save final values of segments
        {
            if (slt64(sext_i32_i64(virt_group_id_6476) *
                      squot64(segred_group_sizze_5518,
                              segment_sizze_nonzzero_6465) +
                      sext_i32_i64(local_tid_6468), n_5370 * p_5372) &&
                slt64(sext_i32_i64(local_tid_6468),
                      squot64(segred_group_sizze_5518,
                              segment_sizze_nonzzero_6465))) {
                float tmp_6493;
                
                tmp_6493 = ((__local
                             float *) red_arr_mem_6472)[(sext_i32_i64(local_tid_6468) +
                                                         (int64_t) 1) *
                                                        segment_sizze_nonzzero_6465 -
                                                        (int64_t) 1];
                ((__global
                  float *) mem_6285)[squot64(sext_i32_i64(virt_group_id_6476) *
                                             squot64(segred_group_sizze_5518,
                                                     segment_sizze_nonzzero_6465) +
                                             sext_i32_i64(local_tid_6468),
                                             p_5372) * p_5372 +
                                     (sext_i32_i64(virt_group_id_6476) *
                                      squot64(segred_group_sizze_5518,
                                              segment_sizze_nonzzero_6465) +
                                      sext_i32_i64(local_tid_6468) -
                                      squot64(sext_i32_i64(virt_group_id_6476) *
                                              squot64(segred_group_sizze_5518,
                                                      segment_sizze_nonzzero_6465) +
                                              sext_i32_i64(local_tid_6468),
                                              p_5372) * p_5372)] = tmp_6493;
            }
        }
        barrier(CLK_LOCAL_MEM_FENCE);
        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);
    }
    
  error_1:
    return;
    #undef segred_group_sizze_5518
}
